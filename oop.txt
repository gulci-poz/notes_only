you don't go fast by rushing
you want to go fast, go well
move deliberately instead of rapidly
coupling (dependency): rigidity, fragility, speghetti (non-reusability)
software design (oo design) ~ cutting the dependencies (immobility)
dependency injection - inversion of control (polymorphism allows that)

SOLID
(S)ingle Responsibility Principle - separation of concerns
(O)pen/Closed Principle - a module should be open for extension, but closed for modification (well enough done abstraction that later provides us polymorphism)
we build good abstraction based on client's response to presented basic code (sprints)
(L)iskov Substitution Principle - we need a common representation (base class interface ~ rather abstract class in java) instead of sharing a relation that is represented (lawyers - divorce example)
we don't want to check the type of an object
inheritance isn't a "is-a" relationship, it's rather sharing a common ancestor
(I)nterface Segregation Principle - many client-specific interfaces are better than one general-purpose interface
(D)ependency Inversion Principle - depend upon abstractions, do not depend upon concretions

Agile/iterative: just enough design to let us move forward successfully.

Continuous process of refinement (agile/iterative):

1. Gather REQUIREMENTS.
We need something written down.
An absolute minimum set of requirements at the beginning.
What the app must do. What problem it solves. Be specific.
Application must... a specific sentence.
Functional requirements: features/capabilities.
Non-functional requirements: help provided, legal requirements, performance requirements, support requirements, security (may be functional requirement).
FURPS/FURPS+ - a checklist
- functional requirements
these are the '-ilities' for non-functional requirements:
- usability requirements (help, documentation, tutorials)
- reliability requirements (disaster recovery, failure rates)
- performance requirements (availability, capacity, resources)
- supportability requirements - who maintains; need of internationalization
+ design requirements (must be an iPhone app etc.)
+ implementation requirements (language, standard, methodology)
+ interface requirements (interface to an external system)
+ physical requirements (physical constraints)

2. DESCRIBE the app.
Build a simple narrative in plain and conversational language for how people use the app. Techniques: use cases and user stories. Smallest set of stories that will make it a real application. May be incomplete and may change.
Sometimes creating a mockup or a prototype of a user interface.

3. IDENTIFY the main objects.
Identifying classes. Most important THINGS from the stories - not everything become a class.

4. Describe the INTERACTIONS.
Formal descriptions. Helps understand responsibilities and behaviours of the objects. Technique: sequence diagram.

5. Create a CLASS DIAGRAM.
Visual representation of the classes. Be specific about OO principles.
